
交叉编译


交叉编译呢，简单地说，就是在一个平台上生成另一个平台上的可执行代码。这里需要注意的是所谓 平台，实际上包含两个概念：体系结构（Architecture）、操作系统（Operating System）。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。 

1词义

一个经常会被问到的问题就是，“既然我们已经有了主机编译器，那为什么还要交叉编译呢？”其实答案很简单，没办法啊！有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；有时是因为目的平台上的资源贫乏，无法运行我们所需要编译器；有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。

 
另一个经常会被问到的问题就是：“既然可以交叉编译，那还要主机编译干吗？”其实答案也很简单，交叉编译是不得已而为之！与主机编译相比，交叉编译受的限制更多，虽然在理论上我们可以做任何形式的交叉编译，但事实上，由于受到专利、版权、技术的限制，并不总是能够进行交叉编译，尤其是在业余条件下！举例来说，我们至今无法生成惠普公司专有的som格式的可执行文件，因此我们根本无法做目的平台为HPPA-HPUX的交叉编译。
 
就我们这个项目而言，需要交叉编译的原因有两个：首先，在项目的起始阶段，目的平台尚未建立，因此需要做交叉编译，以生成我们所需要的bootloader（启动引导代码）以及操作系统核心；其次，当目的平台能启动之后，由于目的平台上资源的限制，当我们编译大型程序时，依然可能需要用到交叉编译。
 
交叉编译这个概念的出现和流行是和嵌入式系统的广泛发展同步的。我们常用的计算机软件，都需要通过编译的方式，把使用高级计算机语言编写的代码（比如C代码）编译（compile）成计算机可以识别和执行的二进制代码。比如，我们在Windows平台上，可使用Visual C++开发环境，编写程序并编译成可执行程序。这种方式下，我们使用PC平台上的Windows工具开发针对Windows本身的可执行程序，这种编译过程称为native compilation，中文可理解为本机编译。然而，在进行嵌入式系统的开发时，运行程序的目标平台通常具有有限的存储空间和运算能力，比如常见的 ARM 平台，其一般的静态存储空间大概是16到32MB，而CPU的主频大概在100MHz到500MHz之间。这种情况下，在ARM平台上进行本机编译就不太可能了，这是因为一般的编译工具链（compilation tool chain）需要很大的存储空间，并需要很强的CPU运算能力。为了解决这个问题，交叉编译工具就应运而生了。通过交叉编译工具，我们就可以在CPU能力很强、存储空间足够的主机平台上（比如PC上）编译出针对其他平台的可执行程序。
 
要进行交叉编译，我们需要在主机平台上安装对应的交叉编译工具链（cross compilation tool chain），然后用这个交叉编译工具链编译我们的源代码，最终生成可在目标平台上运行的代码。常见的交叉编译例子如下：
 
1、在Windows PC上，利用ADS（ARM 开发环境），使用armcc编译器，则可编译出针对ARM CPU的可执行代码。
 
2、在Linux PC上，利用arm-linux-gcc编译器，可编译出针对Linux ARM平台的可执行代码。
 
3、在Windows PC上，利用cygwin环境，运行arm-elf-gcc编译器，可编译出针对ARM CPU的可执行代码。

2基础知识

在做实际工作之前，我想我们应该先掌握一些关于交叉编译的基本知识，其实说白了也就是理解一些我们经常会碰到的英文单词：
 
宿主机（host） ：编辑和编译程序的平台，一般是基于X86的PC机，通常也被称为主机。
 
目标机（target）：用户开发的系统，通常都是非X86平台。host编译得到的可执行代码在target上运行。
 
prefix: 交叉编译器的安装位置。
 
xxx-xxxx-xxxxx 平台描述。
 
我们在主机平台上开发程序，并在这个平台上运行交叉编译器，编译我们的程序；而由交叉编译器生成的程序将在目的平台上运行。这里值得说明得是平台描述，象arm-linux、i386-pc-linux2.4.3这样的字符串我们经常会看到，其实它是用来描述平台的，它有完整格式、缩减格式和别名之分。完整格式是：CPU-制造厂商-操作系统，如sparc-sun-sunos4.1.4，说明平台所使用的CPU是sparc，制造厂商是sun，上面运行的操作系统是SunOS，版本是4.1.4。当然，我们都不愿记这么长的东西，因此可以使用短格式，短格式中有选择地去除了制造厂商、软件版本等信息，因此我们同样可以用sparc-sunos或sparc-sunos-sunos4来描述这个平台。如果觉得这个还是太麻烦，那就可以使用别名，sun4m就可以很简单地描述这个平台。需要注意的是，并不是所有的平台都有别名，也不是所有的短格式都可以正确地描述平台。

3准备素材

怎么说呢，你先得准备好主机平台，对我们这个项目来说，我们建议采用x86 Linux做主机平台，因为这样需要的设置工作最少。当然你也可以使用你所喜欢的平台或你所能得到的平台，其中的区别在于你可能必须做更多的设置工作，当然也有这种可能，就是你所选择的主机平台根本不能生成适用于目标平台的正确的交叉编译器。
 
对于交叉编译器，可以自己生成，也可以从网上下载。区别在于从网上下载非常简单方便，但也许你找不到适合你所选择的平台的。而自己生成交叉编译器，有时会遇到很多挫折，但这的确是个有趣的值得怀念的经历。
 
如果你想自己生成交叉编译器，那你必须先准备下面这些东西：
 
1、磁盘空间。至少要500M左右的空间，如果想一气呵成的话，那就要900M-1G的空间。
 
2、各种源代码。你至少要准备binutils-2.11.2、gcc-2.95.3、linux-2.4.6、newlib-1.8.2或glibc-2.2.2的源代码。
 
如果你所使用的主机平台不是运行的linux，那你还必须注意以下这些问题：
 
1、GNU bash必须是默认shell，所以你也许得把/bin/sh改成bash。
 
2、你要确认已经安装了GNU bison，因为这些软件同样使用了bison扩展。
 
3、GNU gmake最好是系统默认的make，因为这些软件都使用了gmake扩展，如果不是，在需要make时，记得使用gmake。
 
4、如果你想生成交叉glibc，则GNU gsed必须是默认sed，因为glibc会用到gsed的扩展。
 
5、如果你想生成交叉glibc，那还必须准备glibc-linuxthreads-2.2.2的源代码。
 
6、确认正确的路径搜索顺序，最好让GNU软件首先被执行。

4编译器

我们建议使用现成的脚本来生成交叉编译器，因为在配置交叉编译器时，会经常使用一些难以理解的开关项。

5研究实现

伴随着以计算机技术、通讯技术为主的信息技术的飞速发展和互联网的广泛应用，3C(Computer、Communication、ConsumerElectronic)合一将成为必然趋势。信息家电，手持设备，移动设备等嵌入式产品的迅速发展，使得嵌入式软件开发再度成为一个研究热点。 由于嵌入式设备的性能局限，往往不能通过本机编译得到所需软件的可执行程序。因此，以Linux为主机操作系统，搭配一个交叉编译系统，为嵌入式设备生成可执行程序已成为日益流行的编译嵌入式软件的解决方案。而开放源码的编译器GCC，经过多年的发展，已能支持几乎所有知名厂商的处理器，是嵌入式软件开发中理想的交叉编译器。 但现有GCC支持的平台并不能满足层出不穷的嵌入式产品的开发需要，仍有许多平台得不到支持。本论文以交叉编译系统ZLTCG的开发为背景，详细介绍了交叉编译系统GCC的体系结构，对其高度可移植性所依赖的中间表示和机器描述技术进行深入研究，并在此基础上完成了GCC在目标机MIPSX上的移植工作。本文根据新目标机的特点，利用了指令拆分，延时槽调度，窥孔优化等技术，既实现了对新目标机的支持，又吸收了原有系统高度优化和可移植的优点。 论文首先概述了编译系统的发展背景和原理，重点介绍了编译器系统的系统结构、自举与移植。然后介绍了交叉编译系统ZLTCG的开发背景和体系结构。第二章详细分析了编译器GCC，重点说明了GCC的设计思想，系统结构及其中间语言和机器描述文件机制。第三章介绍了交叉编译系统的移植过程，重点解释了移植的思路和方法，移植的准备工作，移植的具体步骤，实现难点及相关的一些技术细节，并给出了移植成功后的测试结果。其中移植的准备工作中详细说明了目标机MIPSX的系统结构和应用二进制接口的定义，而移植的具体步骤中详细阐述了对编译器后端的移植过程。最后是一点总结和展望。



交叉编译器


编译器就是将“高级语言”翻译为“机器语言（低级语言）”的程序。一个现代编译器的主要工作流程：源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 汇编程序 (assembler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables) 

1简介

高级计算机语言便于人编写，阅读，维护。低阶机器语言是计算机能直接解读、运行的。编译器将源程序（Source program）作为输入，翻译产生使用目标语言（Target language）的等价程序。源代码一般为高级语言 (High-level language)， 如 Pascal、C、C++、C#、Java等，而目标语言则是汇编语言或目标机器的目标代码（Object code），有时也称作机器代码（Machine code）。

2原理

编译是从源代码（通常为高阶语言）到能直接被计算机或虚拟机执行的目标代码（通常为低阶语言或机器语言）的翻译过程。然而，也存在从低阶语言到高阶语言的编译器，这类编译器中用来从由高阶语言生成的低阶语言代码重新生成高阶语言代码的又被叫做反编译器。也有从一种高阶语言生成另一种高阶语言的编译器，或者生成一种需要进一步处理的的中间代码的编译器（又叫级联）。
 
典型的编译器输出是由包含入口点的名字和地址， 以及外部调用（到不在这个目标文件中的函数调用）的机器代码所组成的目标文件。一组目标文件，不必是同一编译器产生，但使用的编译器必需采用同样的输出格式，可以链接在一起并生成可以由用户直接执行的可执行程序。

3分类

编译器可以生成用来在与编译器本身所在的计算机和操作系统（平台）相同的环境下运行的目标代码，这种编译器又叫做“本地”编译器。另外，编译器也可以生成用来在其它平台上运行的目标代码，这种编译器又叫做交叉编译器。交叉编译器在生成新的硬件平台时非常有用。“源码到源码编译器”是指用一种高阶语言作为输入，输出也是高阶语言的编译器。例如: 自动并行化编译器经常采用一种高阶语言作为输入，转换其中的代码，并用并行代码注释对它进行注释（如OpenMP）或者用语言构造进行注释（如FORTRAN的DOALL指令）。
 
预处理器（preprocessor）
 
作用是通过代入预定义等程序段将源程序补充完整。
 
编译器前端（frontend）
 
前端主要负责解析（parse）输入的源代码，由语法分析器和语意分析器协同工作。语法分析器负责把源代码中的‘单词’（Token）找出来，语意分析器把这些分散的单词按预先定义好的语法组装成有意义的表达式，语句 ，函数等等。 例如“a = b + c;”前端语法分析器看到的是“a， =， b ， +， c;”，语意分析器按定义的语法，先把他们组装成表达式“b + c”，再组装成“a = b + c”的语句。 前端还负责语义（semantic checking）的检查，例如检测参与运算的变量是否是同一类型的，简单的错误处理。最终的结果常常是一个抽象的语法树（abstract syntax tree，或 AST），这样后端可以在此基础上进一步优化和处理。
 
编译器后端（backend）
 
编译器后端主要负责分析，优化中间代码（Intermediate representation）以及生成机器代码（Code Generation）。
 
一般说来所有的编译器分析，优化，变型都可以分成两大类：函数内（intraprocedural）还是函数之间（interprocedural）进行。很明显，函数间的分析，优化更准确，但需要更长的时间来完成。

4代码分析

编译器分析（compiler analysis）的对象是前端生成并传递过来的中间代码，现代的优化型编译器（optimizing compiler）常常用好几种层次的中间代码来表示程序，高层的中间代码（high levelIR）接近输入的源程序的格式，与输入语言相关（language dependent），包含更多的全局性的信息，和源程序的结构；中层的中间代码（middle level IR）与输入语言无关，低层的中间代码(Low level IR)与机器语言类似。 不同的分析，优化发生在最适合的那一层中间代码上。
 
常见的编译分析有函数调用树（call tree），控制流程图（Control flow graph），以及在此基础上的 变量定义－使用，使用－定义链（define-use/use-define or u-d/d-u chain），变量别名分析（alias analysis），指针分析（pointer analysis），数据依赖分析（data dependenceanalysis）等。
 
程序分析结果是编译器优化（compileroptimization）和程序变形（compiler transformation）的前提条件。常见的优化和变形有：函数内嵌（inlining），无用代码删除（Dead code elimination），标准化循环结构（loop normalization），循环体展开（loop unrolling），循环体合并，分裂（loop fusion，loop fission），数组填充（array padding），等等。 优化和变形的目的是减少代码的长度，提高内存（memory），缓存（cache）的使用率，减少读写磁盘，访问网络数据的频率。更高级的优化甚至可以把序列化的代码（serial code）变成并行运算，多线程的代码（parallelized，multi-threaded code）。
 
机器代码的生成是优化变型后的中间代码转换成机器指令的过程。现代编译器主要采用生成汇编代码（assembly code）的策略，而不直接生成二进制的目标代码（binary object code）。即使在代码生成阶段，高级编译器仍然要做很多分析，优化，变形的工作。例如如何分配寄存器（register allocatioin），如何选择合适的机器指令（instruction selection），如何合并几句代码成一句等等。

5工作方法

首先编译器进行语法分析，也就是要把那些字符串分离出来。
 
然后进行语义分析，就是把各个由语法分析分析出的语法单元的意义搞清楚。
 
最后生成的是目标文件，也称为obj文件。
 
再经过链接器的链接就可以生成最后的可执行代码了。
 
有些时候需要把多个文件产生的目标文件进行链接，产生最后的代码。这一过程称为交叉链接。

6语言对比

许多人将高阶程序语言分为两类:编译型语言和 直译型语言 。然而，实际上，这些语言中的大多数既可用编译型实现也可用直译型实现，分类实际上反映的是那种语言常见的实现方式。（但是，某些直译型语言，很难用编译型实现。比如那些允许 在线代码更改 的直译型语言。）

7发展历史

20世纪50年代，IBM的John Backus带领一个研究小组对FORTRAN语言及其编译器进行开发。但由于当时人们对编译理论了解不多，开发工作变得既复杂又艰苦。与此同时，Noam Chomsky开始了他对自然语言结构的研究。他的发现最终使得编译器的结构异常简单，甚至还带有了一些自动化。Chomsky的研究导致了根据语言文法的难易程度以及识别它们所需要的算法来对语言分类。正如所称的Chomsky架构（Chomsky Hierarchy），它包括了文法的四个层次：0型文法、1型文法、2型文法和3型文法，且其中的每一个都是其前者的特殊情况。2型文法（或上下文无关文法）被证明是程序设计语言中最有用的，而且今天它已代表着程序设计语言结构的标准方式。分析问题（parsing problem，用于上下文无关文法识别的有效算法）的研究是在60年代和70年代，它相当完善的解决了这个问题。它已是编译原理中的一个标准部分。
 
有限状态自动机（Finite Automation）和正则表达式（Regular Expression）同上下文无关文法紧密相关，它们与Chomsky的3型文法相对应。对它们的研究与Chomsky的研究几乎同时开始，并且引出了表示程序设计语言的单词的符号方式。
 
人们接着又深化了生成有效目标代码的方法，这就是最初的编译器，它们被一直使用至今。人们通常将其称为优化技术（Optimization Technique），但因其从未真正地得到过被优化了的目标代码而仅仅改进了它的有效性，因此实际上应称作代码改进技术（Code Improvement Technique）。
 
当分析问题变得好懂起来时，人们就在开发程序上花费了很大的功夫来研究这一部分的编译器自动构造。这些程序最初被称为编译器的编译器（Compiler-compiler），但更确切地应称为分析程序生成器（Parser Generator），这是因为它们仅仅能够自动处理编译的一部分。这些程序中最著名的是Yacc（Yet Another Compiler-compiler），它是由Steve Johnson在1975年为Unix系统编写的。类似的，有限状态自动机的研究也发展了一种称为扫描程序生成器（Scanner Generator）的工具，Lex（与Yacc同时，由Mike Lesk为Unix系统开发）是这其中的佼佼者。
 
在20世纪70年代后期和80年代早期，大量的项目都贯注于编译器其它部分的生成自动化，这其中就包括了代码生成。这些尝试并未取得多少成功，这大概是因为操作太复杂而人们又对其不甚了解。
 
编译器设计最近的发展包括：首先，编译器包括了更加复杂算法的应用程序它用于推断或简化程序中的信息；这又与更为复杂的程序设计语言的发展结合在一起。其中典型的有用于函数语言编译的Hindley-Milner类型检查的统一算法。其次，编译器已越来越成为基于窗口的交互开发环境（Interactive Development Environment，IDE）的一部分，它包括了编辑器、连接程序、调试程序以及项目管理程序。这样的IDE标准并没有多少，但是对标准的窗口环境进行开发已成为方向。另一方面，尽管在编译原理领域进行了大量的研究，但是基本的编译器设计原理在近20年中都没有多大的改变，它正迅速地成为计算机科学课程中的中心环节。
 
在20世纪90年代，作为GNU项目或其它开放源代码项目标一部分，许多免费编译器和编译器开发工具被开发出来。这些工具可用来编译所有的计算机程序语言。它们中的一些项目被认为是高质量的，而且对现代编译理论感兴趣的人可以很容易的得到它们的免费源代码。
 
大约在1999年，SGI公布了他们的一个工业化的并行化优化编译器Pro64的源代码，后被全世界多个编译器研究小组用来做研究平台，并命名为Open64。Open64的设计结构好，分析优化全面，是编译器高级研究的理想平台。

8交叉编译

在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码。这里需要注意的是所谓平台，实际上包含两个概念：体系结构（Architecture）、操作系统（Operating System）。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。
 
有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；有时是因为目的平台上的资源贫乏，无法运行我们所需要编译器；有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。
 
交叉编译这个概念的出现和流行是和嵌入式系统的广泛发展同步的。我们常用的计算机软件，都需要通过编译的方式，把使用高级计算机语言编写的代码（比如C代码）编译（compile）成计算机可以识别和执行的二进制代码。比如，我们在Windows平台上，可使用Visual C++开发环境，编写程序并编译成可执行程序。这种方式下，我们使用PC平台上的Windows工具开发针对Windows本身的可执行程序，这种编译过程称为native compilation，中文可理解为本机编译。然而，在进行嵌入式系统的开发时，运行程序的目标平台通常具有有限的存储空间和运算能力，比如常见的 ARM 平台，其一般的静态存储空间大概是16到32MB，而CPU的主频大概在100MHz到500MHz之间。这种情况下，在ARM平台上进行本机编译就不太可能了，这是因为一般的编译工具链（compilation tool chain）需要很大的存储空间，并需要很强的CPU运算能力。为了解决这个问题，交叉编译工具就应运而生了。通过交叉编译工具，我们就可以在CPU能力很强、存储空间足够的主机平台上（比如PC上）编译出针对其他平台的可执行程序。
 
要进行交叉编译，我们需要在主机平台上安装对应的交叉编译工具链（cross compilation tool chain），然后用这个交叉编译工具链编译我们的源代码，最终生成可在目标平台上运行的代码。


交叉编译环境

编辑
 


交叉编译（cross-compilation）是指，在某个主机平台上（比如PC上）用交叉编译器编译出可在其他平台上（比如ARM上）运行的代码的过程。
 
交叉编译这个概念的出现和流行是和嵌入式系统的广泛发展同步的。我们常用的计算机软件，都需要通过编译的方式，把使用高级计算机语言编写的代码（比如 C代码）编译（compile）成计算机可以识别和执行的二进制代码。比如，我们在 Windows 平台上，可使用 Visual C++ 开发环境，编写程序并编译成可执行程序。这种方式下，我们使用 PC 平台上的 Windows 工具开发针对 Windows 本身的可执行程序，这种编译过程称为 native compilation，中文可理解为本机编译。然而，在进行嵌入式系统的开发时，则不能直接编译。原因有俩：一、运行程序的目标平台通常具有有限的存储空间和运算能力，比如常见的 ARM 平台，其一般的静态存储空间大概是 16 到 32 MB，而 CPU 的主频大概在 100MHz 到 500MHz 之间。这种情况下，在 ARM 平台上进行本机编译就不太可能了，这是因为一般的编译工具链（compilation tool chain）需要很大的存储空间，并需要很强的 CPU 运算能力。为了解决这个问题，交叉编译工具就应运而生了。通过交叉编译工具，我们就可以在 CPU 能力很强、存储控件足够的主机平台上（比如 PC 上）编译出针对其他平台的可执行程序。二、宿主机与目标机的运行环境并不相同，所以必须要提供不同的类库，使得宿主机上开发的代码能在目标机上运行。


