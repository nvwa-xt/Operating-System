不能实现由用户来选择调度算法和多算法集成,不能给用户提供统一的用户使用界面。为此,提出了一种新的调度机制,它能够给用户提供统一的使用界面,支持所有的调度算法且隐含实现的细节,使用户更方便地使用各种调度算法、
处理意外事件的硬件机制
当异常或中断发生时，硬件或软件就能检测到它们，并捕获正在执行的线程，CPU会从用户态切换到核心态，将暂停正在处理的事情，把控制转交给内核的陷阱处理程序。同时，该模块还能检测异常和中断的类型，并将控制交给处理相应情况的代码。因此，陷阱调度机制是当异常或者中断发生时，能够保存当前线程状态并转向相应处理的一种系统机制。
避免阻塞在那些需要同时处理很多客户端的服务器程序里非常有用。
调度激活使得当内核觉得要调度用户线程时会通知用户线程。在内核里面相关的内核事件会导致用户线程调度器重新决定调度事宜，决定哪个线程应该运行在哪个虚拟cpu上。这个机制通过引进一个新的名叫upcall的系统调用来实现。upcall是一个内核到应用的调用，和传统的应用调用内核服务的 downcall相反。内核就是利用调度激活来实现upcall的，一个调度激活是一个和传统内核线程一样的执行环境上下文。事实上，调度激活在好多系统 的实现正是利用了内核线程，只是加上了upcall。在传统的内核线程，都要指派给它自己一个函数，然后交给操作系统运行，调度激活正好相反，它是操作系 统觉得要用调度激活时，就会先创建一个调度激活，然后开始运行一个事先指定好的用户函数。（

Windows是一款微内核、抢占式多任务、软实时的操作系统。
Windows的任务调度主要以线程为单位进行，线程拥有33个优先级，数值为0~32，其中0为最低优先级，32为最高优先级，最高和最低优先级均保留给系统使用。用户可以使用的优先级为1～31。
Windows按照优先级高低顺序来进行任务的调度，当调度发生时，内核首先检查高优先级的线程是否 就绪，如果有发现有高优先级的线程就绪则立刻将高优先级的线程发往CPU执行。如果有高优先级的线程就绪，就不会执行低优先级的任务。不 过，windows使用成为“饥渴”的时间片分配策略，如果有线程一直渴望得到时间片但是很长时间都没有获得时间片，windows就会临时将这个线程的 优先级提高，并一次分配给2倍的时间片来执行，但是windows绝不会将这个线程的优先级提高到实时优先级范围（16～31为实时优先级范围），如果不 希望windows进行饥渴分配策略，也可以通过特定的API将该策略关闭（SetThreadPriorityBoost）。

Windows同时采用时间片策略来执行相同优先级的任务。相同优先级的线程会获得同样的时间片（一 般为2个系统Tick，在单CPU系统上一个系统Tick一般为10ms，多CPU系统上一般为15ms，可以通过 GetSystemTimeAdjustment查询）。一个线程的时间片用完后，Windows会将另外一个已经就绪的同优先级的线程发往CPU进行执 行。正在执行的线程将在线程主动放弃时间片（比如调用Sleep函数），时间片用完或Windows发现有更高优先级的线程就绪后暂停执行。

另外，Windows还存在不受优先级策略控制的线程，如DPC的处理线程，Windows中每个CPU上都有一个DPC队列，只要DPC中有等待处理的任务，Windows总是会立刻对DPC中的任务进行处理。

Windows和硬实时操作系统的区别在于，硬实时操作系统一般拥有256或更多的优先级，硬实时操 作系统的最重要特性在于中断的处理方式方面，Windows使用DPC队列方式来延时处理中断请求，在ISR中仅能执行时间非常关键的硬件寄存器操作（如 恢复清除设备中断寄存器使得设备能进行下一次中断），DPC队列按照先入先出的方式执行，这样如果系统在短时间发生大量中断而使得DPC队列中存在大量待 处理的中断请求时，时间关键的中断请求可能会在很长时间后才得到处理，使得系统丧失实时响应能力。硬实时操作系统的ISR同样一般仅能执行时间关键的硬件 寄存器操作，也必须通过任务调度切换至相关的任务上下文环境，才能访问更多的资源来进行相关的处理，但是硬实时操作系统可以根据优先级来处理中断的请求， 后发生的高优先级中断请求可以抢占低优先级中断或低优先级任务的时间片，而使得时间关键的中断请求总是能得到最优先的处理。

对各种操作系统的任务调度策略进行深入的理解之后，才能对一套应用系统的设计进行精确的把握。 Windows的调度策略很适合处理各种非事件性的数据，比如大量的流数据，可以达到很高的数据吞吐量。如果你设计的系统是需要实时响应的中断事件式的处 理，那么你可能需要考虑使用一款硬实时的操作系统，如Windows CE 5.0以上版本，或vxWorks，WindowsCE有很好的硬实时的处理能力，价格低廉，开发容易，缺点是可用软件少。而vxWorks功能强大，有 庞大的gnu软件阵容做后盾，唯一美中不足的是价格昂贵。其他免费的操作系统只会令你的项目陷入困境，如果做的是有的是时间没有钱的项目，才值得考虑。

既然是“核心”就一定是很重要的东西，在linux中称作“内核”，它的任务是 和硬件联系说白了就是它指挥硬件去做事，就像一个指挥官一样，什么计算之类的它也有参与，反正它做很多事，那我们人怎么和它联系呢？那就要靠“翻译官”shell了，我们所有打的命令都是通过shell翻译给“内核”看，内核明白了，然后指挥硬件做事，做完之后联系shell，shell返回结果给人（说的有点笼统了）。具体的呢你可以去查资料。good luck！！

调度程序运行时，要在所有可运行状态的进程中选择最值得运行的进程投入运行。选择进程的依据是什么呢？在每个进程的task_struct结构中有以下四 项：policy、priority、counter、rt_priority。这四项是选择进程的依据。其中，policy是进程的调度策略，用来区分 实时进程和普通进程，实时进程优先于普通进程运行；priority是进程(包括实时和普通)的静态优先级；counter是进程剩余的时间片，它的起始 值就是priority的值；由于counter在后面计算一个处于可运行状态的进程值得运行的程度goodness时起重要作用，因此，counter 也可以看作是进程的动态优先级。rt_priority是实时进程特有的，用于实时进程间的选择。 Linux用函数goodness()来衡量一个处于可运行状态的进程值得运行的程度。该函数综合了以上提到的四项，还结合了一些其他的因素，给每个处于 可运行状态的进程赋予一个权值(weight)，调度程序以这个权值作为选择进程的唯一依据。关于goodness()的情况在后面将会详细分析。

对于队列机制而言，它的最重要的两个特性就是调度方式和丢弃机制，在学习队列机制时要从这两个特性去考察、对比不同队列机制之间的共同点和不同点，明白不同队列机制不同的应用场合。






队列调度机制
 

调度方式
 

丢弃机制
 



FIFO
 

顺序调度
 

尾丢弃
 



PQ
 

首先调度高优先级队列
 

尾丢弃
 



CQ
 

从每个队列取指定字节的报文，队列之间采用RR机制
 

尾丢弃
 



WFQ
 

先调度SN小的报文
 

改进的尾丢弃
 



CBWFQ
 

保证每个队列的设定带宽
 

尾丢弃或WRED
 



LLQ
 

首先服务低时延队列，但是低时延队列有阀值
 

尾丢弃或WRED
 



IP RTP priority
 

首先服务低时延队列，但是低时延队列有阀值
 

尾丢弃
 


















